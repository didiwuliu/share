<!DOCTYPE html>
<!--
    Google HTML5 slide template
    
    Authors: Luke Mahé (code)
             Marcin Wichary (code and design)
             
             Dominic Mazzoni (browser compatibility)
             Charles Chen (ChromeVox support)
    
    URL: http://code.google.com/p/html5slides/
    -->
<html>
<head>
    <title>使用nodejs构建web网站 - 张春生</title>
    <meta charset='utf-8'>
    <script src='http://didiwuliu.github.io/share/node/slides.js'></script>
</head>
<style>
    /* Your individual styles here, or just use inline styles if that’s
    what you want. */
</style>
<body style='display: none'>
<section class='slides layout-regular template-yongche'>
<!-- Your slides (<article>s) go here. Delete or comment out the
    slides below. -->
<article class='biglogo'>
</article>

<article>
    <h1>
        使用nodejs构建web网站
    </h1>
    <p>
        张春生
        <br>
        2014年5月3日
    </p>
</article>

<article>
    <h3>
        概述
    </h3>
    <ul class="build">
        <li>nodejs基础</li>
        <li>构建web网站</li>
        <li>events模块</li>
        <li>http模块</li>
        <li>websocket</li>
    </ul>
    </p>
</article>

<article>
    <h3>
        nodejs基础
    </h3>
    <ul>
        <li>
            node安装
        </li>
        <li>
            hello world
            <p>
                <section>
                    <pre>
  function helloWorld() {
    console.log("hello world!");
  }
  helloWorld();
</pre>
                </section>
            </p>
        </li>
        <li>CommonJS规范</li>
        <li>NPM包管理</li>
        <li>工程目录</li>
    </ul>
</article>

<article class="smaller">
    <h3>
        CommonJS规范
    </h3>
    <p>Node.js采用CommnJS规范</p>
    <p>
        根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。下面就是一个简单的模块文件example.js。
        <pre>
exports.message = "hello world!";

exports.say = function () {
  console.log(message);
}
        </pre>
    </p>
    <p>
        使用require方法，加载example.js。<br/>
        var example = require('./example.js');<br/>
        这时，变量example就对应模块中的exports对象，于是就可以通过这个变量，使用模块提供的各个方法。
        {
        message: "hello world!",
        say: [Function]
        }
    </p>
</article>

<article class="smaller">
    <h3>
        CommonJS规范
    </h3>
    <p>
        require方法默认读取js文件，所以可以省略js后缀名。
        <pre>var example = require('./example');</pre>
    </p>
    <p>
        js文件名前面需要加上路径，可以是相对路径（相对于使用require方法的文件），也可以是绝对路径。如果省略路径，node.js会认为，你要加载一个核心模块，或者已经安装在本地 node_modules 目录中的模块。如果加载的是一个目录，node.js会首先寻找该目录中的 package.json 文件，加载该文件 main 属性提到的模块，否则就寻找该目录下的 index.js 文件。
    </p>
    <p>
        有时，不需要exports返回一个对象，只需要它返回一个函数。这时，就要写成module.exports。

        <pre>
module.exports = function () {
    console.log("hello world")
}
</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        NPM包管理
    </h3>
    <p>
        NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：
    </p>
    <ul>
        <li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
        <li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
        <li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
    </ul>
    <p>
        可以看到，NPM建立了一个NodeJS生态圈，NodeJS开发者和用户可以在里边互通有无。
    </p>
    <h4>模块的安装</h4>
    <p>
        每个模块可以“全局安装”，也可以“本地安装”。两者的差异是模块的安装位置，以及调用方法。
        “全局安装”指的是将一个模块直接下载到Node的安装目录中，各个项目都可以调用。“本地安装”指的是将一个模块下载到当前目录的node_modules子目录，然后只有在当前目录和它的子目录之中，才能调用这个模块。一般来说，全局安装只适用于工具模块，比如npm和grunt。
        默认情况下，npm install 命令是“本地安装”某个模块。
    </p>
</article>

<article class="smaller">
    <h3>NPM包管理</h3>
    <p>
        <pre>npm install [package name]</pre>
    </p>
    <p>
        npm也支持直接输入github地址。
    </p>
    <p>
        <pre>npm install git://github.com/package/path.git
npm install git://github.com/package/path.git#0.1.0</pre>
    </p>
    <p>
        使用安装命令以后，模块文件将下载到当前目录的 node_modules 子目录。
        使用global参数，可以“全局安装”某个模块。
        <pre>sudo npm install -global [package name]</pre>
    </p>
    <p>
        global参数可以被简化成g参数。
        <pre>sudo npm install -g [package name]</pre>
    </p>
</article>

<article class="smaller">
    <h3>NPM包管理</h3>
    <p>
        install命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上@和版本号。
        <pre>npm install package_name@version</pre>
    </p>
    <p>
        一旦安装了某个模块，就可以在代码中用require命令调用这个模块。
        <pre>var backbone = require('backbone')
console.log(backbone.VERSION)</pre>
    </p>
    <h4>模块的升级和删除</h4>
    <p>
        npm update 命令可以升级本地安装的模块。
        <pre>npm update [package name]</pre>
    </p>
</article>

<article class="smaller">
    <h3>NPM包管理</h3>
    <p>
        加上global参数，可以升级全局安装的模块。
    <pre>npm update -global [package name]</pre>
    </p>
    <p>
        npm uninstall 命令，删除本地安装的模块。
    <pre>npm uninstall [package name]</pre>
    </p>
    <p>
        加上global参数，可以删除全局安装的模块。
    <pre>sudo npm uninstall [package name] -global</pre>
    </p>

    <h4>列出当前项目的模块</h4>
    <p>
        npm list命令，默认列出当前目录安装的所有模块。如果使用global参数，就是列出全局安装的模块。
    </p>
</article>

<article class="smaller">
    <h3>NPM包管理</h3>
    <p>
        <pre>npm list
npm -global list</pre>
    </p>

    <h4>模块搜索</h4>
    <p>
        向服务器端搜索某个模块，使用search命令（可使用正则搜索）。
        <pre>npm search [搜索词]</pre>
    </p>

    <h4>模块的发布</h4>
    <p>
        在发布你的模块之前，需要先设定个人信息。
        <pre>npm set init.author.name "xxx"
npm set init.author.email "xxx@yongche.com"
npm set init.author.url "http://www.yongche.com"</pre>
    </p>
</article>

<article class="smaller">
    <h3>NPM包管理</h3>
    <p>
        然后，请npm系统申请用户名。
        <pre>npm adduser</pre>
    </p>
    <p>
        运行上面的命令之后，屏幕上会提示输入用户名，然后是输入Email地址和密码。
        上面所有的这些个人信息，全部保存在~/.npmrc文件之中。
    </p>
    <p>
        npm模块就是一个遵循CommonJS规范的JavaScript脚本文件。此外，在模块目录中还必须有一个提供自身信息的package.json文件，一般采用npm init命令生成这个文件。
        <pre>npm init</pre>
    </p>
    <p>
        运行上面的命令，会提示回答一系列问题，结束后自动生成package.json文件。
        package.json文件中的main属性，指定模块加载的入口文件，默认是index.js。在index.js文件中，除了模块代码以外，主要使用require命令加载其他模块，使用module.exports变量输出模块接口。
    </p>
</article>

<article class="smaller">
    <h3>NPM包管理</h3>
    <p>
        完成代码以后，再加一个README.md文件，用来给出说明文本。
        最后，使用npm publish命令发布。
        <pre>npm publish</pre>
    </p>
    <p>
        package.json详细说明
        <a href="https://www.npmjs.org/doc/json.html" target="_blank">https://www.npmjs.org/doc/json.html</a>
    </p>
    <ul>
        <li>name 包名，在NPM服务器上须要保持唯一</li>
        <li>version 当前版本号</li>
        <li>description 第三方包依赖，需要指定包名和版本号</li>
        <li>keywords</li>
        <li>main 入口模块位置</li>
        <li>bin 命令行程序名和主模块位置</li>
        <li>dependencies</li>
        <li>devDependencies</li>
    </ul>
</article>

<article class="smaller">
    <h3>NPM包管理</h3>
    <p>
        NPM使用语义版本号来管理代码
        语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。
    </p>
    <ul>
        <li>+ 如果只是修复bug，需要更新Z位。</li>
        <li>+ 如果是新增了功能，但是向下兼容，需要更新Y位。</li>
        <li>+ 如果有大变动，向下不兼容，需要更新X位。</li>
    </ul>
    <h4 style="margin-top:10px;margin-bottom:10px;">npm命令</h4>
    <p>
        <pre>npm help 查看所有命令
npm help &lt;command&gt; 可查看某条命令的详细帮助
npm install. -g 可先在本地安装当前命令行程序，可用于发布前的本地测试。
npm update &lt;package&gt; 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。
npm update &lt;package&gt; -g 可以把全局安装的对应命令行程序更新至最新版。
npm cache clear 可以清空NPM本地缓存
npm unpublish &lt;package&gt;@&lt;version&gt; 以撤销发布自己发布过的某个版本代码
npm config list -l 查看配置
npm info &lt;name&gt; 查看模块信息
npm update -global npm 更新npm</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        工程目录
    </h3>
    <p>
        <pre>
- /home/user/workspace/yongche-echo/   # 工程目录
    - bin/                          # 存放命令行相关代码
        node-echo
     + doc/                          # 存放文档
    - lib/                          # 存放API相关代码
        echo.js
    - node_modules/                 # 存放三方包
        + argv/
    + tests/                        # 存放测试用例
    package.json                    # 元数据文件
    README.md                       # 说明文件
        </pre>
    </p>
</article>

<article>
    <h3>
        构建web网站
    </h3>
    <ul>
        <li>Express简介</li>
        <li>MVC设计</li>
        <li>Session管理</li>
        <li>数据库操作</li>
        <li>负载均衡</li>
    </ul>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        Express是目前最流行的基于Node.js的Web开发框架。它可以快速地搭建网站原型。
        Express是一个node.js模块，采用npm全局模块。
        <pre>sudo npm install -g express-generator@4</pre>
    </p>
    <p>
        安装完成后，在工作目录新建一个新项目，假定叫做node-demo。
        <pre>express node-demo</pre>
    </p>
    <p>
        这时，工作目录中就会生成一个node-demo子目录。进入该目录，安装所需要的模块。
        <pre>cd node-demo
npm installl</pre>
    </p>
    <p>
        如果浏览这个子目录，就会发现express自动生成了以下的子目录和文件。
    </p>
    <ul>
        <li>node_modules子目录：用于安装本地模块。</li>
    </ul>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <ul>
        <li>public子目录：用于存放用户可以下载到的文件，比如图片、脚本、样式表等。</li>
        <li>routes子目录：用于存放路由文件。</li>
        <li>views子目录：用于存放网页的模板。</li>
        <li>app.js文件：应用程序的启动脚本。</li>
        <li>package.json文件：项目的配置文件。</li>
    </ul>
    <p>
        然后，在命令行下运行下面的命令，就可以在浏览器中访问项目网站了。
        <pre>node app</pre>
    </p>
    <p>
        默认情况下，网站运行在本机的3000端口，网页显示Welcome to Express。
    </p>
    <h4>
        运行原理
    </h4>
    <p>
        底层：http模块<br />
        Express框架建立在node.js内置的http模块上。
        http模块生成服务器的原始代码如下。
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        <pre>
var http = require("http");
var app = http.createServer(function(request, response) {
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.end("Hello world!\n");
});
app.listen(1337, "localhost");
console.log("Server running at http://localhost:1337/");</pre>
    </p>
    <p>
        上面代码的关键是http模块的createServer方法，表示生成一个HTTP服务器实例。该方法接受一个回调函数，该回调函数的参数，分别为代表HTTP请求和HTTP回应的request对象和response对象。
    </p>
    <p>
        对http模块的再包装<br />
        Express框架的核心是对http模块的再包装。上面的代码用Express改写如下。
        <pre style="margin-top:1px;">var express = require("express");
var http = require("http");
var app = express();
app.use(function(request, response) {
    response.writeHead(200, { "Content-Type": "text/plain" });
    response.end("Hello world!\n");
});
http.createServer(app).listen(1337);</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        比较两段代码，可以看到它们非常接近，唯一的差别是createServer方法的参数，从一个回调函数变成了一个Epress对象的实例。而这个实例使用了use方法，加载了与上一段代码相同的回调函数。
        Express框架等于在http模块之上，加了一个中间层，而use方法则相当于调用中间件。
    </p>
    <h4 style="margin-bottom:10px;">
        什么是中间件
    </h4>
    <p>
        简单说，中间件（middleware）就是处理HTTP请求的函数，用来完成各种特定的任务，比如检查用户是否登录、分析数据、以及其他在需要最终将数据发送给用户之前完成的任务。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。
    </p>
    <p>
        node.js的内置模块http的createServer方法，可以生成一个服务器实例，该实例允许在运行过程中，调用一系列函数（也就是中间件）。当一个HTTP请求进入服务器，服务器实例会调用第一个中间件，完成后根据设置，决定是否再调用下一个中间件。中间件内部可以使用服务器实例的response对象（ServerResponse，即回调函数的第二个参数），以及一个next回调函数（即第三个参数）。每个中间件都可以对HTTP请求（request对象）做出回应，并且决定是否调用next方法，将request对象再传给下一个中间件。
    </p>
    <p>
        一个不进行任何操作、只传递request对象的中间件，大概是下面这样：
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        <pre>
function uselessMiddleware(req, res, next) {
    next();
}</pre>
    </p>
    <p>
        上面代码的next为中间件的回调函数。如果它带有参数，则代表抛出一个错误，参数为错误文本。
    </p>
    <p>
        <pre>
function uselessMiddleware(req, res, next) {
    next('出错了！');
}</pre>
    </p>
    <p>
        抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。
    </p>
    <h4>
        use方法
    </h4>
    <p>
        use是express调用中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子。
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        <pre>
var express = require("express");
var http = require("http");
var app = express();
app.use(function(request, response, next) {
    console.log("In comes a " + request.method + " to " + request.url);
    next();
});
app.use(function(request, response) {
    response.writeHead(200, { "Content-Type": "text/plain" });
    response.end("Hello world!\n");
});
http.createServer(app).listen(1337);
</pre>
    </p>
    <p>
        上面代码先调用第一个中间件，在控制台输出一行信息，然后通过next方法，调用第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方法，所以不再request对象就不再向后传递了。
    </p>
    <p>
        使用use方法，可以根据请求的网址，返回不同的网页内容。
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        <pre>
var express = require("express");
var http = require("http");
var app = express();
app.use(function(request, response, next) {
  if (request.url == "/") {
    response.writeHead(200, { "Content-Type": "text/plain" });
    response.end("Welcome to the homepage!\n");
  } else {
    next();
  }
});
app.use(function(request, response, next) {
  if (request.url == "/about") {
    response.writeHead(200, { "Content-Type": "text/plain" });
  } else {
    next();
  }
});
app.use(function(request, response) {
  response.writeHead(404, { "Content-Type": "text/plain" });
  response.end("404 error!\n");
});
http.createServer(app).listen(1337);
</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。
        除了在回调函数内部，判断请求的网址，Express也允许将请求的网址写在use方法的第一个参数。
        <pre style="margin-top:1px;margin-bottom: 1px;">
        app.use('/', someMiddleware);</pre>
    </p>
    <p>
        上面代码表示，只对根目录的请求，调用某个中间件。
        因此，上面的代码可以写成下面的样子。
        <pre style="margin-top:1px;">
var express = require("express");
var http = require("http");
var app = express();
app.use("/", function(request, response, next) {
    response.writeHead(200, { "Content-Type": "text/plain" });
    response.end("Welcome to the homepage!\n");
});
app.use("/about", function(request, response, next) {
    response.writeHead(200, { "Content-Type": "text/plain" });
    response.end("Welcome to the about page!\n");
});
app.use(function(request, response) {
    response.writeHead(404, { "Content-Type": "text/plain" });
    response.end("404 error!\n");
});

http.createServer(app).listen(1337);</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <h4 style="margin-top:10px;margin-bottom: 10px;">
        Express的方法
    </h4>
    <p>
        all方法和HTTP动词方法<br />
        针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写。
        <pre>
var express = require("express");
var http = require("http");
var app = express();
app.all("*", function(request, response, next) {
    response.writeHead(200, { "Content-Type": "text/plain" });
next();
});
app.get("/", function(request, response) {
    response.end("Welcome to the homepage!");
});
app.get("/about", function(request, response) {
    response.end("Welcome to the about page!");
});
app.get("*", function(request, response) {
    response.end("404!");
});
http.createServer(app).listen(1337);</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了。
    </p>
    <p>
        除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法。
    </p>
    <p>
        这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配。
        <pre>
app.get("/hello/:who", function(req, res) {
    res.end("Hello, " + req.params.who + ".");
});</pre>
    </p>
    <p>
        上面代码将匹配“/hello/alice”网址，网址中的alice将被捕获，作为req.params.who属性的值。需要注意的是，捕获后需要对网址进行检查，过滤不安全字符，上面的写法只是为了演示，生产中不应这样直接使用用户提供的值。
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        如果在模式参数后面加上问号，表示该参数可选。
        <pre>
app.get('/hello/:who?',function(req,res) {
if(req.params.id) {
    res.end("Hello, " + req.params.who + ".");
}
else {
    res.send("Hello, Guest.");
}
});</pre>
    </p>
    <p>
        下面是一些更复杂的模式匹配的例子。
        <pre>
app.get('/forum/:fid/thread/:tid', middleware)
// 匹配/commits/71dbb9c
// 或/commits/71dbb9c..4c084f9这样的git格式的网址
app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
    var from = req.params[0];
    var to = req.params[1] || 'HEAD';
    res.send('commit range ' + from + '..' + to);
});</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <h4>
        set方法
    </h4>
    <p>
        set方法用于指定变量的值。
        <pre>
app.set("views", __dirname + "/views");
app.set("view engine", "jade");</pre>
    </p>
    <p>
        上面代码使用set方法，为系统变量“views”和“view engine”指定值。
    </p>
    <h4 style="margin-bottom: 10px;">
        response对象
    </h4>
    <p>
        response.redirect方法<br />
        response.redirect方法允许网址的重定向。
        <pre>
response.redirect("/hello/anime");
response.redirect("http://www.example.com");
response.redirect(301, "http://www.example.com");</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        response.sendFile方法<br />
        response.sendFile方法用于发送文件。
        <pre>
        response.sendFile("/path/to/anime.mp4");</pre>
    </p>
    <p>
        response.render方法<br />
        response.render方法用于渲染网页模板。
        <pre>
app.get("/", function(request, response) {
    response.render("index", { message: "Hello World" });
});</pre>
    </p>
    <p>
        上面代码使用render方法，将message变量传入index模板，渲染成HTML网页。
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <h4>
        requst对象
    </h4>
    <p>
        request.ip<br />
        request.ip属性用于获得HTTP请求的IP地址。
    </p>
    <p>
        request.files<br />
        request.files用于获取上传的文件。
    </p>
    <h4>
        项目开发实例
    </h4>
    <p>
        上一节使用express命令自动建立项目，也可以不使用这个命令，手动新建所有文件。
    </p>
    <p>
        先建立一个项目目录（假定这个目录叫做demo）。进入该目录，新建一个package.json文件，写入项目的配置信息。
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        <pre>{
    "name": "demo",
    "description": "My First Express App",
    "version": "0.0.1",
    "dependencies": {
        "express": "3.x"
    }
}</pre>
    </p>
    <p>
        在项目目录中，新建文件app.js。项目的代码就放在这个文件里面。
        <pre>
var express = require('express');
var app = express();</pre>
    </p>
    <p>
        上面代码首先加载express模块，赋给变量express。然后，生成express实例，赋给变量app。
        接着，设定express实例的参数。
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        <pre>
// 设定port变量，意为访问端口
app.set('port', process.env.PORT || 3000);

// 设定views变量，意为视图存放的目录
app.set('views', path.join(__dirname, 'views'));

// 设定view engine变量，意为网页模板引擎
app.set('view engine', 'jade');

app.use(express.favicon());
app.use(express.logger('dev'));
app.use(express.bodyParser());
app.use(express.methodOverride());
app.use(app.router);

// 设定静态文件目录，比如本地文件
// 目录为demo/public/images，访问
// 网址则显示为http://localhost:3000/images
app.use(express.static(path.join(__dirname, 'public')));</pre>
    </p>
    <p>
        上面代码中的set方法用于设定内部变量，use方法用于调用express的中间件。
        最后，调用实例方法listen，让其监听事先设定的端口（3000）。
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        <pre>app.listen(app.get('port'));</pre>
    </p>
    <p>
        这时，运行下面的命令，就可以在浏览器访问http://127.0.0.1:3000。
        <pre>node app.js</pre>
    </p>
    <p>
        网页提示“Cannot GET /”，表示没有为网站的根路径指定可以显示的内容。所以，下一步就是配置路由。
    </p>
    <h4>
        配置路由
    </h4>
    <p>
        所谓“路由”，就是指为不同的访问路径，指定不同的处理方法。
        指定根路径
        在app.js之中，先指定根路径的处理方法。
        <pre>
app.get('/', function(req, res) {
    res.send('Hello World');
});</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        上面代码的get方法，表示处理客户端发出的GET请求。相应的，还有app.post、app.put、app.del（delete是JavaScript保留字，所以改叫del）方法。
    </p>
    <p>
        get方法的第一个参数是访问路径，正斜杠（/）就代表根路径；第二个参数是回调函数，它的req参数表示客户端发来的HTTP请求，res参数代表发向客户端的HTTP回应，这两个参数都是对象。在回调函数内部，使用HTTP回应的send方法，表示向浏览器发送一个字符串。然后，运行下面的命令。
        <pre>node app.js</pre>
    </p>
    <p>
        此时，在浏览器中访问http://127.0.0.1:3000，网页就会显示“Hello World”。
        如果需要指定HTTP头信息，回调函数就必须换一种写法，要使用setHeader方法与end方法。
        <pre>
app.get('/', function(req, res){
    var body = 'Hello World';
    res.setHeader('Content-Type', 'text/plain');
    res.setHeader('Content-Length', body.length);
    res.end(body);
});</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <h4>
        指定特定路径
    </h4>
    <p>
        上面是处理根目录的情况，下面再举一个例子。假定用户访问/api路径，希望返回一个JSON字符串。这时，get可以这样写。
        <pre>
app.get('/api', function(request, response) {
    response.send({name:"张三",age:40});
});</pre>
    </p>
    <p>
        上面代码表示，除了发送字符串，send方法还可以直接发送对象。重新启动node以后，再访问路径/api，浏览器就会显示一个JSON对象。
        <pre>
{
    "name": "张三",
    "age": 40
}</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        我们也可以把app.get的回调函数，封装成模块。先在routes目录下面建立一个api.js文件。
        <pre>
// routes/api.js
exports.index = function (req, res){
    res.json(200, {name:"张三",age:40});
}</pre>
    </p>
    <p>
        现在访问时，就会显示与上一次同样的结果。
        如果只向浏览器发送简单的文本信息，上面的方法已经够用；但是如果要向浏览器发送复杂的内容，还是应该使用网页模板。
    </p>
    <h4>
        静态网页模板
    </h4>
    <p>
        在项目目录之中，建立一个子目录views，用于存放网页模板。
        假定这个项目有三个路径：根路径（/）、自我介绍（/about）和文章（/article）。那么，app.js可以这样写：
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        <pre>
var express = require('express');
var app = express();

app.get('/', function(req, res) {
   res.sendfile('./views/index.html');
});

app.get('/about', function(req, res) {
   res.sendfile('./views/about.html');
});

app.get('/article', function(req, res) {
   res.sendfile('./views/article.html');
});

app.listen(3000);</pre>
    </p>
    <p>
        上面代码是一个静态网页。如果想要展示动态内容，就必须使用动态网页模板。
    </p>
    <h4>
        动态网页模板
    </h4>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        网站真正的魅力在于动态网页，下面我们来看看，如何制作一个动态网页的网站。
    </p>
    <p>
        安装模板引擎<br />
        Express支持多种模板引擎，这里采用Handlebars模板引擎的服务器端版本hbs模板引擎。<br />
        先安装hbs。
        <pre style="margin-top:1px;">npm install hbs --save-dev</pre>
    </p>
    <p>
        上面代码将hbs模块，安装在项目目录的子目录node_modules之中。save-dev参数表示，将依赖关系写入package.json文件。安装以后的package.json文件变成下面这样：
        <pre style="margin-top:1px;">
// package.json文件
{
    "name": "demo",
    "description": "My First Express App",
    "version": "0.0.1",
    "dependencies": {
        "express": "4.x"
    },
    "devDependencies": {
        "hbs": "~2.3.1"
    }
}</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p style="margin-top:1px;padding-top:1px;">
        安装模板引擎之后，就要改写app.js。
        <pre style="margin-top:1px;margin-bottom:1px;">
// app.js文件
var express = require('express');
var app = express();
// 加载hbs模块
var hbs = require('hbs');
// 指定模板文件的后缀名为html
app.set('view engine', 'html');
// 运行hbs模块
app.engine('html', hbs.__express);
app.get('/', function (req, res){
    res.render('index');
});
app.get('/about', function(req, res) {
    res.render('about');
});
app.get('/article', function(req, res) {
    res.render('article');
});</pre>
    </p>
    <p style="margin-top:1px;padding-top:1px;">
        上面代码改用render方法，对网页模板进行渲染。render方法的参数就是模板的文件名，默认放在子目录views之中，后缀名已经在前面指定为html，这里可以省略。所以，res.render('index') 就是指，把子目录views下面的index.html文件，交给模板引擎hbs渲染。
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <h4 style="margin-top:10px;margin-bottom:10px;">
        新建数据脚本
    </h4>
    <p>
        渲染是指将数据代入模板的过程。实际运用中，数据都是保存在数据库之中的，这里为了简化问题，假定数据保存在一个脚本文件中。
        在项目目录中，新建一个文件blog.js，用于存放数据。blog.js的写法符合CommonJS规范，使得它可以被require语句加载。
        <pre style="margin-top:1px;">
// blog.js文件
var entries = [
    {"id":1, "title":"第一篇", "body":"正文", "published":"6/2/2013"},
    {"id":2, "title":"第二篇", "body":"正文", "published":"6/3/2013"},
    {"id":3, "title":"第三篇", "body":"正文", "published":"6/4/2013"},
    {"id":4, "title":"第四篇", "body":"正文", "published":"6/5/2013"},
    {"id":5, "title":"第五篇", "body":"正文", "published":"6/10/2013"},
    {"id":6, "title":"第六篇", "body":"正文", "published":"6/12/2013"}
];
exports.getBlogEntries = function () {
    return entries;
}
exports.getBlogEntry = function (id) {
    for(var i=0; i < entries.length; i++) {
        if(entries[i].id == id)
            return entries[i];
    }
}</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <h4>
        新建网页模板
    </h4>
    <p>
        接着，新建模板文件index.html。
        <pre>
    <!-- views/index.html文件 -->
&lt;h1&gt;文章列表&lt;/h1&gt;
{{#each entries}}
&lt;p&gt;
    &lt;a href="/article/{{id}}">{{title}}&lt;/a&gt;&lt;br/&gt;
    Published: {{published}}
&lt;/p&gt;
{{/each}}</pre>
    </p>
    <p>
        模板文件about.html。
        <pre>
&lt;!-- views/about.html文件 --&gt;
&lt;h1&gt;自我介绍&lt;/h1&gt;
&lt;p&gt;正文&lt;/p&gt;
</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        模板文件article.html。
        <pre style="margin-top:1px;margin-bottom: 1px;">
&lt;!-- views/article.html文件 --&gt;
&lt;h1>{{blog.title}}&lt;/h1&gt;
Published: {{blog.published}}
&lt;p/&gt;
{{blog.body}}</pre>
    </p>
    <p style="margin-top:1px;">
        可以看到，上面三个模板文件都只有网页主体。因为网页布局是共享的，所以布局的部分可以单独新建一个文件layout.html。
        <pre style="margin-top:1px;">
&lt;!-- views/layout.html文件 --&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{{title}}&lt;/title&gt;
    &lt;/head&gt;
&lt;body&gt;
{{{body}}}
&lt;footer&gt;
    &lt;p&gt;
        &lt;a href="/"&gt;首页&lt;/a&gt; - &lt;a href="/about"&gt;自我介绍&lt;/a&gt;
    &lt;/p&gt;
&lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <h4 style="margin-top:10px;margin-bottom: 10px;">
        渲染模板
    </h4>
    <p>
        最后，改写app.js文件。
        <pre style="margin-top:1px;">
// app.js文件
var express = require('express');
var app = express();
var hbs = require('hbs');
// 加载数据模块
var blogEngine = require('./blog');
app.set('view engine', 'html');
app.engine('html', hbs.__express);
app.use(express.bodyParser());
app.get('/', function(req, res) {
    res.render('index',{title:"最近文章", entries:blogEngine.getBlogEntries()});
});
app.get('/about', function(req, res) {
    res.render('about', {title:"自我介绍"});
});
app.get('/article/:id', function(req, res) {
    var entry = blogEngine.getBlogEntry(req.params.id);
    res.render('article',{title:entry.title, blog:entry});
});
app.listen(3000);</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        上面代码中的render方法，现在加入了第二个参数，表示模板变量绑定的数据。
        现在重启node服务器，然后访问http://127.0.0.1:3000。
        <pre>node app.js</pre>
    </p>
    <p>
        可以看得，模板已经使用加载的数据渲染成功了。
    </p>
    <h4 style="margin-top:10px;margin-bottom: 10px;">
        指定静态文件目录
    </h4>
    <p>
        模板文件默认存放在views子目录。这时，如果要在网页中加载静态文件（比如样式表、图片等），就需要另外指定一个存放静态文件的目录。
    <pre>app.use(express.static('public'));</pre>
    </p>
    <p>
        上面代码在文件app.js之中，指定静态文件存放的目录是public。于是，当浏览器发出非HTML文件请求时，服务器端就到public目录寻找这个文件。比如，浏览器发出如下的样式表请求：
    <pre>&lt;link href="/bootstrap/css/bootstrap.css" rel="stylesheet"&gt;</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        服务器端就到public/bootstrap/css/目录中寻找bootstrap.css文件。
    </p>
    <h4>
        ExpressJS 4.0的Router用法
    </h4>
    <p>
        Express 4.0的Router用法，做了大幅改变，增加了很多新的功能。Router成了一个单独的组件，好像小型的express应用程序一样，有自己的use、get、param和route方法。<br />
        基本用法<br />
        Express 4.0的router对象，需要单独新建。然后，使用该对象的HTTP动词方法，为不同的访问路径，指定回调函数；最后，挂载到某个路径<br />
        <pre>
var router = express.Router();
router.get('/', function(req, res) {
    res.send('首页');
});
router.get('/about', function(req, res) {
    res.send('关于');
});
app.use('/', router);</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        上面代码先定义了两个访问路径，然后将它们挂载到根目录。如果最后一行改为app.use('/app', router)，则相当于/app和/app/about这两个路径，指定了回调函数。
    </p>
    <p>
        这种挂载路径和router对象分离的做法，为程序带来了更大的灵活性，既可以定义多个router对象，也可以为将同一个router对象挂载到多个路径。
    </p>
    <h5 style="margin-top:10px;margin-bottom: 10px;">router.route方法</h5>
    <p>
        router实例对象的route方法，可以接受访问路径作为参数。
        <pre style="margin-top: 1px;">
var router = express.Router();
router.route('/api')
    .post(function(req, res) {
        // ...
    })
    .get(function(req, res) {
        Bear.find(function(err, bears) {
            if (err)
                res.send(err);
            res.json(bears);
        });
    });
app.use('/', router);</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <h5 style="margin-top:10px;margin-bottom: 10px;">router中间件</h5>
    <p>
        use方法为router对象指定中间件，即在数据正式发给用户之前，对数据进行处理。下面就是一个中间件的例子。
        <pre>
router.use(function(req, res, next) {
    console.log(req.method, req.url);
    next();
});</pre>
    </p>
    <p>
        上面代码中，回调函数的next参数，表示接受其他中间件的调用。函数体中的next()，表示将数据传递给下一个中间件。
    </p>
    <p>
        注意，中间件的放置顺序很重要，等同于执行顺序。而且，中间件必须放在HTTP动词方法之前，否则不会执行。
    </p>
    <h5 style="margin-top:10px;margin-bottom: 10px;">对路径参数的处理</h5>
    <p>
        router对象的param方法用于路径参数的处理，可以
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        <pre>
router.param('name', function(req, res, next, name) {
    // 对name进行验证或其他处理……
    console.log(name);
    req.name = name;
    next();
});

router.get('/hello/:name', function(req, res) {
    res.send('hello ' + req.name + '!');
});</pre>
    </p>
    <p>
        上面代码中，get方法为访问路径指定了name参数，param方法则是对name参数进行处理。注意，param方法必须放在HTTP动词方法之前。
    </p>
    <h5 style="margin-top:10px;margin-bottom: 10px;">app.route</h5>
    <p>
        假定app是Express的实例对象，Express 4.0为该对象提供了一个route属性。app.route实际上是express.Router()的缩写形式，除了直接挂载到根路径。因此，对同一个路径指定get和post方法的回调函数，可以写成链式形式。
    </p>
</article>

<article class="smaller">
    <h3>
        Express简介
    </h3>
    <p>
        <pre>
app.route('/login')
    .get(function(req, res) {
        res.send('this is the login form');
    })
    .post(function(req, res) {
        console.log('processing');
        res.send('processing the login form!');
    });</pre>
    </p>
    <p>
        上面代码的这种写法，显然非常简洁清晰。
    </p>
</article>

<article class="smaller">
    <h3>
        MVC设计
    </h3>
    <p>
        使用Router和模板
    </p>
    <p>
        其他框架backbone和underscore都可以尝试使用
    </p>
</article>

<article class="smaller">
    <h3>
        Session管理
    </h3>
    <ul>
        <li>session保存到数据库</li>
        <li>使用redis保存session</li>
    </ul>
</article>

<article class="smaller">
    <h3>
        数据库操作
    </h3>
    <ul>
        <li>mysql https://github.com/felixge/node-mysql</li>
        <li>mongodb https://github.com/kissjs/node-mongoskin</li>
        <li>redis https://github.com/mranney/node_redis</li>
    </ul>
</article>

<article class="smaller">
    <h3>
        负载均衡
    </h3>
    <ul>
        <li><a href="https://github.com/Unitech/pm2" target="_blank">https://github.com/Unitech/pm2</a></li>
        <li>阿里 node-cluster（隐藏了）</li>
        <li>指定cpu 使用taskset -pc 0 19277  （其中0代表CPU0，以此类推）</li>
        <li>cluster模块</li>
    </ul>
</article>

<article class="smaller">
    <h3>
        events模块
    </h3>
    <h4>
        基本用法
    </h4>
    <p>
        events模块是node.js对“发布/订阅”模式（publish/subscribe）的部署。也就说，通过events模块的EventEmitter属性，建立一个消息中心；然后通过on方法，为各种事件指定回调函数，从而将程序转为事件驱动型，各个模块之间通过事件联系。
        <pre>
var EventEmitter = require("events").EventEmitter;
var ee = new EventEmitter();
ee.on("someEvent", function () {
    console.log("event has occured");
});
ee.emit("someEvent");
        </pre>
    </p>
    <p>
        上面代码在加载events模块后，通过EventEmitter属性建立了一个EventEmitter对象实例，这个实例就是消息中心。然后，通过on方法为someEvent事件指定回调函数。最后，通过emit方法触发someEvent事件。
    </p>
</article>

<article class="smaller">
    <h3>
        events模块
    </h3>
    <p>
        emit方法还接受第二个参数，用于向回调函数提供参数。
        <pre>
ee.on("someEvent", function (data){
    console.log(data);
});
ee.emit("someEvent", data);
//默认情况下，Node.js允许同一个事件最多可以触发10个回调函数。
ee.on("someEvent", function () { console.log("event 1"); });
ee.on("someEvent", function () { console.log("event 2"); });
ee.on("someEvent", function () { console.log("event 3"); });
//超过10个回调函数，会发出一个警告。这个门槛值可以通过setMaxListeners方法改变。
ee.setMaxListeners(20);
//events模块的作用，还表示在其他模块可以继承这个模块，因此也就拥有了EventEmitter接口。
var util = require("util");
var EventEmitter = require("events").EventEmitter;
function UserList () {
    EventEmitter.call(this);
}
util.inherits(UserList, EventEmitter);
UserList.prototype.save = function (obj) {
    // save into database
    this.emit("saved-user", obj);
};</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        events模块
    </h3>
    <p>
        上面代码新建了一个构造函数UserList，然后让其继承EventEmitter，因此UserList就拥有了EventEmitter的接口。最后，为UserList的实例定义一个save方法，表示将数据储存进数据库，在储存完毕后，使用EventEmitter接口的emit方法，触发一个saved-user事件。
    </p>
    <h4>
        事件类型
    </h4>
    <p>
        events模块默认支持一些事件。
    </p>
    <ul>
        <li>newListener事件：添加新的回调函数时触发。</li>
        <li>removeListener事件：移除回调时触发。</li>
    </ul>
</article>

<article class="smaller">
    <h3>
        events模块
    </h3>
    <p>
        <pre>ee.on("newListener", function (evtName){
    console.log("New Listener: " + evtName);
});

ee.on("removeListener", function (evtName){
    console.log("Removed Listener: " + evtName);
});

function foo (){}

ee.on("save-user", foo);
ee.removeListener("save-user", foo);

// New Listener: removeListener
// New Listener: save-user
// Removed Listener: save-user</pre>
    </p>
    <p>
        上面代码会触发两次newListener事件，以及一次removeListener事件。
    </p>
    <h4>EventEmitter对象的其他方法</h4>
</article>

<article class="smaller">
    <h3>
        events模块
    </h3>
    <p>
        once方法<br />
        该方法类似于on方法，但是回调函数只触发一次。
        <pre>ee.once("firstConnection", function (){
    console.log("本提示只出现一次");
});</pre>
    </p>
    <p>
        removeListener方法<br />
        该方法用于移除回调函数。它接受两个参数，第一个是事件名称，第二个是回调函数名称。这就是说，不能用于移除匿名函数。
        <pre>function onlyOnce () {
    console.log("You'll never see this again");
    ee.removeListener("firstConnection", onlyOnce);
}‘
ee.on("firstConnection", onlyOnce);</pre>
    </p>
    <p>
        上面代码起到与once方法类似效果。
    </p>
</article>

<article class="smaller">
    <h3>
        events模块
    </h3>
    <p>
        removeAllListeners方法<br />
        该方法用于移除某个事件的所有回调函数。
        <pre style="margin-top:1px;">ee.removeAllListeners("firstConnection");</pre>
    </p>
    <p>
        如果不带参数，则表示移除所有事件的所有回调函数。
        <pre style="margin-top:1px;">ee.removeAllListeners();</pre>
    </p>
    <p>
        listener方法<br />
        该方法接受一个事件名称作为参数，返回该事件所有回调函数组成的数组。
        <pre style="margin-top:1px;">function onlyOnce () {
    console.log(ee.listeners("firstConnection"));
    ee.removeListener("firstConnection", onlyOnce);
    console.log(ee.listeners("firstConnection"));
}
ee.on("firstConnection", onlyOnce)
ee.emit("firstConnection");
ee.emit("firstConnection");
// [ [Function: onlyOnce] ]
// []</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        events模块
    </h3>
    <p>
        上面代码显示两次回调函数组成的数组，第一次只有一个回调函数onlyOnce，第二次是一个空数组，因为removeListener方法取消了回调函数。
    </p>
</article>

<article class="smaller">
    <h3>
        http模块
    </h3>
    <p>
        NodeJS本来的用途是编写高性能Web服务器。我们首先在这里重复一下官方文档里的例子，使用NodeJS内置的http模块简单实现一个HTTP服务器。
        <pre>var http = require('http');
http.createServer(function (request, response) {
    response.writeHead(200, { 'Content-Type': 'text-plain' });
    response.end('Hello World\n');
}).listen(8080);
console.log('Server running on port 8080.');</pre>
    </p>
    <p>
        上面代码第一行 var http = require("http")，表示加载http模块。然后，调用http模块的createServer方法，创造一个服务器实例，将它赋给变量http。
    </p>
    <p>
        ceateServer方法接受一个函数作为参数，该函数的req参数是一个对象，表示客户端的HTTP请求；res参数也是一个对象，表示服务器端的HTTP回应。rese.writeHead方法表示，服务器端回应一个HTTP头信息；response.end方法表示，服务器端回应的具体内容，以及回应完成后关闭本次对话。最后的listen(8080)表示启动服务器实例，监听本机的8080端口。
        将上面这几行代码保存成文件app.js，然后用node调用这个文件，服务器就开始运行了。
        <pre style="margin-top:1px;">node app.js</pre>
    </p>
</article>

<article class="smaller">
    <h3>
        http模块
    </h3>
    <p>
        这时命令行窗口将显示一行提示“Server running at port 8080.”。打开浏览器，访问http://localhost:8080，网页显示“Hello world!”。
    </p>
    <p>
        上面的例子是当场生成网页，也可以事前写好网页，存在文件中，然后利用fs模块读取网页文件，将其返回。
        <pre>
var http = require('http');
var fs = require('fs');

http.createServer(function (request, response){

fs.readFile('data.txt', function readData(err, data) {
    response.writeHead(200, {'Content-Type': 'text/plain'});
    response.end(data);
});

}).listen(8080, "127.0.0.1");

console.log('Server running on port 8080.');
</pre>
    </p>
    <p>
        下面的修改则是根据不同网址的请求，显示不同的内容，已经相当于做出一个网站的雏形了。
    </p>
</article>

<article class="smaller">
    <h3>
        http模块
    </h3>
    <p>
        <pre>
var http = require("http");
http.createServer(function(req, res) {
    // 主页
    if (req.url == "/") {
        res.writeHead(200, { "Content-Type": "text/html" });
        res.end("Welcome to the homepage!");
    }
    // About页面
    else if (req.url == "/about") {
        res.writeHead(200, { "Content-Type": "text/html" });
        res.end("Welcome to the about page!");
    }
    // 404错误
    else {
        res.writeHead(404, { "Content-Type": "text/plain" });
        res.end("404 error! File not found.");
    }
}).listen(8080, "localhost");
        </pre>
    </p>
    <p>
        回调函数的req（request）对象，拥有以下属性。
    </p>
</article>

<article class="smaller">
    <h3>
        http模块
    </h3>
    <ul>
        <li>url：发出请求的网址。</li>
        <li>method：HTTP请求的方法。</li>
        <li>headers：HTTP请求的所有HTTP头信息。</li>
    </ul>
    <h4 style="margin-top:10px;margin-bottom:10px">处理POST请求</h4>
    <p>
        当客户端采用POST方法发送数据时，服务器端可以对data和end两个事件，设立监听函数。
        <pre style="margin-top:1px;">
var http = require('http');
http.createServer(function (req, res) {
    var content = "";
    req.on('data', function (chunk) {
        content += chunk;
    });
    req.on('end', function () {
        res.writeHead(200, {"Content-Type": "text/plain"});
        res.write("You've sent: " + content);
        res.end();
    });
}).listen(8080);
        </pre>
    </p>
</article>

<article class="smaller">
    <h3>
        http模块
    </h3>
    <h4 style="margin-top:10px;margin-bottom:10px">
        发出请求：request方法
    </h4>
    <p style="margin-top:10px;margin-bottom:10px">
    request方法用于发出HTTP请求。
    <pre style="margin-top:1px;overflow-x:scroll">
var http = require('http');
//The url we want is: 'www.random.org/integers/?num=1&min=1&max=10&col=1&base=10&format=plain&rnd=new'
var options = {
    host: 'www.random.org',
    path: '/integers/?num=1&min=1&max=10&col=1&base=10&format=plain&rnd=new'
};
var callback = function(response) {
    var str = '';
    //another chunk of data has been received, so append it to `str`
    response.on('data', function (chunk) {
        str += chunk;
    });
    //the whole response has been received, so we just print it out here
    response.on('end', function () {
        console.log(str);
    });
}
var req = http.request(options, callback);
req.write("hello world!");
req.end();
    </pre>
    </p>
</article>

<article class="smaller">
    <h3>
        http模块
    </h3>
    <p>
        request对象的第一个参数是options对象，用于指定请求的域名和路径，第二个参数是请求完成后的回调函数。
        <pre>
//如果使用POST方法发出请求，只需在options对象中设定即可。
var options = {
    host: 'www.example.com',
    path: '/',
    port: '80',
    method: 'POST'
};

//指定HTTP头信息，也是在options对象中设定。
var options = {
    headers: {'custom': 'Custom Header Demo works'}
};
        </pre>
    </p>
    <h4>
        搭建HTTPs服务器
    </h4>
</article>

<article class="smaller">
    <h3>
        http模块
    </h3>
    <p>
        搭建HTTPs服务器需要有SSL证书。对于向公众提供服务的网站，SSL证书需要向证书颁发机构购买；对于自用的网站，可以自制。
        自制SSL证书需要OpenSSL，具体命令如下。
        <pre style="margin-top:1px">
openssl genrsa -out key.pem
openssl req -new -key key.pem -out csr.pem
openssl x509 -req -days 9999 -in csr.pem -signkey key.pem -out cert.pem
rm csr.pem
        </pre>
    </p>
    <p>
        上面的命令生成两个文件：cert.pem（证书文件）和 key.pem（私钥文件）。有了这两个文件，就可以运行HTTPs服务器了。
        <pre style="margin-top:1px">
var https = require('https');
var fs = require('fs');
var options = {
    key: fs.readFileSync('key.pem'),
    cert: fs.readFileSync('cert.pem')
};
var server = https.createServer(options, function (req, res) {
    res.writeHead(200);
    res.end("hello world\n");
}).listen(8000);
        </pre>
    </p>
</article>

<article class="smaller">
    <h3>
        http模块
    </h3>
    <p>
        上面代码显示，HTTPs服务器与HTTP服务器的最大区别，就是createServer方法多了一个options参数。运行以后，就可以测试是否能够正常访问。
    <pre>curl -k https://localhost:8000</pre>
    </p>
    <p>
        http说明官方文档： <a href="http://nodejs.org/api/http.html" target="_blank">http://nodejs.org/api/http.html</a>
    </p>
</article>

<article class='smaller'>
    <h3>
        websocket
    </h3>
</article>

<article>
    <h1 style="text-align:center">
        谢谢!
    </h1>
</article>

</section>
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-31588662-5', 'didiwuliu.github.io');
    ga('send', 'pageview');

</script>
</body>
</html>